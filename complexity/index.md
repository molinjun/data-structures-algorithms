# 算法复杂度与大O计法

在介绍数据结构和算法之前，我们首先来了解一下算法的复杂度（Complexity）分析。

## 为什么需要复杂度分析？

对于同一个问题，我们可以通过多种算法来实现。比如排序问题，我们就有冒泡排序、归并排序和快排等十种排序算法来实现。不同的算法都有各自的优点和缺点。那怎么来评价一个算法的优劣呢？一个好的算法有两个重要的指标：`运行时间短`，`占用空间少`。

那我们要怎么统计不同的算法运行时间呢？通过输入一组测试数据来运行一遍程序，记录不同算法的运行时间，可以吗？不太可行。因为程序运行的时间受测试环境的影响，同一个端代码在不同的 CPU 的运行时间就不一样。另外，测试的数据也影响到测试结果。例如，当数据规模比较小的时候，插入排序可能比快速排序还快。所以，我们需要在`不通过具体的测试数据，不用实际运行程序，就可以粗略地估算出算法的执行效率`。这就是算法的复杂度分析。**算法复杂度(complexity)**，可以从`时间复杂度`和`空间复杂度`两个维度来考虑。

## 怎么分析复杂度？

我们可以粗略统计代码的`执行次数`。以一个累加和的程序为例：

```js
function add(n) {
  let sum = 0; // 执行 1 次

  // i=1, 执行 1 次; i<n, 执行 n + 1 次; i++, 执行 n 次
  for (let i = 1; i <= n; i++) {
    sum += i; // 执行 n 次
  }
  return sum; // 执行 1 次
}
// 总次数f(n) = 1 + 1 + n+1 + n + n + 1 = 3n+4
```

这段求和的代码的执行次数 `f(n)`为 `3n+4` ，假设代码执行一次的时间为 `t`，则算法执行的总时间 `T(n)`就是：
$$
T(n) = f(n) * t =（3n + 4）* t
$$
尽管我们并不知道时间 `t` 的大小，但我们可以看到代码的`总执行时间`随`数据规模 n`增长 的变化趋势，从而评估算法的执行效率。这种方法是可行的，但这表达式也太复杂了。我们需要一种更简洁、更直观的表示方法，这就是我们要讲的`大 O 记法`。e

## 大 O 记法

首先，让我们来感受一下它的概念。对于单调函数` f(n)` 和` g(n)`, n为正整数，如果存在常数 c > 0, n<sub>0</sub> >0,且
$$
f(n) ≤ c * g(n),  n ≥ n0
$$
则我们称:
$$
f(n) = O(g(n))
$$
如图所示：

![大O记法](https://github.com/gedennis/javascript-sorting/raw/master/1.big_O_nation/bigO.png)

简单来说，就是当 n 趋向无穷大时，g(n) 是 f(n) 的上界。把大O记法应用到我们上面的时间复杂度就是：
```
T(n) = O(f(n)) = O(3n + 4)
```
  T(n) 就是我们根据代码执行次数 f(n) 估算的复杂度上界 O(3n + 4)。这里我必须介绍大O记法的两个特性：`加法法则`和`乘法法则`。

```latex
加法法则： O(f1(n)) + O(f2(n)) = max(O(f1(n)), O(f2(n)))
乘法法则： O(f1(n)) * O(f2(n)) = O(f1(n) * f2(n))
```

可知，加法法则就是，保留表达式中量级最大的项，忽略常数项和参数。根据加法法则，我们上面的时间复杂度简化为
```Latex
T(n) = O(3n + 4) = O(n) + O(n) + O(n) + O(4) = O(n)
```
这不就是我们熟悉的 O(n) 吗？原来是这么推算出来的。可见，复杂度的计算只需要关注量级最大的代码执行次数。

## 时间复杂度

我们再通过一个例子来练习一下。下面是一个生成一个 N * N 矩阵的代码（仅做示范用）。

```js
function makeMatrix(n) {
  const matrix = [];      // 执行 1 次
  
  // i=1, 1次; i<=n, n+1 次；i++， n次
  for (let i = 1; i <= n; i++) {
    const row = [];  // n 次
     // j=1, 1 * n 次; j<=n, (n+1)*n 次；j++， n*n次
    for (let j = 1; j <= n; j++) {
      row.push(i * j); //n * n 次
    }
    matrix.push(row); // n次
  }
  return matrix; // 1 次
}
```

嵌套循环中的代码次数，等于内外循环执行次数的乘积。以上代码的执行总次数f(n) = 3n<sup>2</sup> + 5n + 4，所以复杂度可以表示为：
```
T(n)=O(3n^2+ 5n + 4) = O(n^2)
```
这也就是我们常见的 O(n<sup>2</sup>) 时间复杂度了。现在我们应该学会怎么样利用大O记法去计算时间复杂度了。

但每段代码都这样去计算时间复杂度也太麻烦了。对，是比较麻烦，但当你还是新手的时候，建议这样去算几遍熟悉一下。当然，平常我们肯定不需要这样费劲，简单几步就可以估算出来。怎么做呢？通过这两段代码的练习，大家有没有发现：

- 对于没有循环的代码，它的时间复杂度都是 O(1)
- 对于循环代码，我们只需要关注最内层循环的代码执行次数

`更简单来说，我们只需要关注一段代码里是否有循环，如果有就直接看最内层循环的时间复杂度`。

## 常见的时间复杂度

复杂度的量级大体由以下几种：

- 常量阶 O(1) 
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n<sup>2</sup>)
- 指数阶 O(2<sup>n</sup>)
- 阶乘阶O(n!)

各种时间复杂度的执行效率如下图所示：

<img src="/Users/dennisge/Library/Application Support/typora-user-images/image-20201223173741587.png" alt="image-20201223173741587" style="zoom:50%;" />

如图可见，指数阶和阶乘阶的算法执行效率已经太低了，我们这里就不介绍了。我们

- 最好复杂度
- 最坏时间复杂度
- 平均复杂度
- 均摊时间复杂度

- 大 O 记法的原理
- - 
- 练习





## 参考

- [Big-O Complexity Chart](https://www.bigocheatsheet.com/)
- [循序渐进带你学习时间复杂度和空间复杂度](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650563136&idx=1&sn=c03ac8a5548ea28b34d624569855922e&chksm=f1fed4c3c6895dd56d079a5de77568c31cd9934ecb388ce6ba876002fec4b3487b6c5d51d984&scene=0#rd)
- [数据结构与算法之美](https://time.geekbang.org/column/article/40036)
- [You need to understand Big O notation](https://hackernoon.com/you-need-to-understand-big-o-notation-now-4ada3d2ec93a)

