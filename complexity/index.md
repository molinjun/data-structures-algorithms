# 算法复杂度与大O计法

在介绍数据结构和算法之前，我们首先来了解一下算法的复杂度（Complexity）分析。

## 为什么需要复杂度分析？

对于同一个问题，我们可以通过多种算法来实现。比如排序问题，我们就有冒泡排序、归并排序和快排等十种排序算法来实现。不同的算法都有各自的优点和缺点。那怎么来评价一个算法的优劣呢？一个好的算法有两个重要的指标：`运行时间短`，`占用空间少`。

那我们要怎么统计不同的算法运行时间呢？通过输入一组测试数据来运行一遍程序，记录不同算法的运行时间，可以吗？不太可行。因为程序运行的时间受测试环境的影响，同一个端代码在不同的 CPU 的运行时间就不一样。另外，测试的数据也影响到测试结果。例如，当数据规模比较小的时候，插入排序可能比快速排序还快。所以，我们需要在`不通过具体的测试数据，不用实际运行程序，就可以粗略地估算出算法的执行效率`。这就是算法的复杂度分析。**算法复杂度(complexity)**，可以从`时间复杂度`和`空间复杂度`两个维度来考虑。

## 怎么分析复杂度？

我们可以粗略统计代码的`执行次数`。以一个累加和的程序为例：

```js
function add(n) {
  let sum = 0; // 执行 1 次

  // i=1, 执行 1 次; i<n, 执行 n + 1 次; i++, 执行 n 次
  for (let i = 1; i <= n; i++) {
    sum += i; // 执行 n 次
  }
  return sum; // 执行 1 次
}
// 总次数f(n) = 1 + 1 + n+1 + n + n + 1 = 3n+4
```

这段求和的代码的执行次数 `f(n)`为 `3n+4` ，假设代码执行一次的时间为 `t`，则算法执行的总时间 `T(n)`就是：
$$
T(n) = f(n) * t =（3n + 4）* t
$$
尽管我们并不知道时间 `t` 的大小，但我们可以看到代码的`总执行时间`随`数据规模 n`增长 的变化趋势，从而评估算法的执行效率。这种方法是可行的，但这表达式也太复杂了。我们需要一种更简洁、更直观的表示方法，这就是我们要讲的`大 O 记法`。e

## 大 O 记法

首先，让我们来感受一下它的概念。对于单调函数` f(n)` 和` g(n)`, n为正整数，如果存在常数 c > 0, n<sub>0</sub> >0,且
$$
f(n) ≤ c * g(n),  n ≥ n0
$$
则我们称:
$$
f(n) = O(g(n))
$$
如图所示：

![大O记法](https://github.com/gedennis/javascript-sorting/raw/master/1.big_O_nation/bigO.png)

简单来说，就是当 n 趋向无穷大时，g(n) 是 f(n) 的上界。把大O记法应用到我们上面的时间复杂度就是：
```
T(n) = O(f(n)) = O(3n + 4)
```
  T(n) 就是我们根据代码执行次数 f(n) 估算的复杂度上界 O(3n + 4)。这里我必须介绍大O记法的两个特性：`加法法则`和`乘法法则`。

```latex
加法法则： O(f1(n)) + O(f2(n)) = max(O(f1(n)), O(f2(n)))
乘法法则： O(f1(n)) * O(f2(n)) = O(f1(n) * f2(n))
```

可知，加法法则就是，保留表达式中量级最大的项，忽略常数项和参数。根据加法法则，我们上面的时间复杂度简化为
```Latex
T(n) = O(3n + 4) = O(n) + O(n) + O(n) + O(4) = O(n)
```
这不就是我们熟悉的 O(n) 吗？原来是这么推算出来的。可见，复杂度的计算只需要关注量级最大的代码执行次数。

## 时间复杂度

我们再通过一个例子来练习一下。下面是一个生成一个 N * N 矩阵的代码（仅做示范用）。

```js
function makeMatrix(n) {
  const matrix = [];      // 执行 1 次
  
  // i=1, 1次; i<=n, n+1 次；i++， n次
  for (let i = 1; i <= n; i++) {
    const row = [];  // n 次
     // j=1, 1 * n 次; j<=n, (n+1)*n 次；j++， n*n次
    for (let j = 1; j <= n; j++) {
      row.push(i * j); //n * n 次
    }
    matrix.push(row); // n次
  }
  return matrix; // 1 次
}
```

嵌套循环中的代码次数，等于内外循环执行次数的乘积。以上代码的执行总次数f(n) = 3n<sup>2</sup> + 5n + 4，所以复杂度可以表示为：
```
T(n)=O(3n^2+ 5n + 4) = O(n^2)
```
这也就是我们常见的 O(n<sup>2</sup>) 时间复杂度了。现在我们应该学会怎么样利用大O记法去计算时间复杂度了。

但每段代码都这样去计算时间复杂度也太麻烦了。对，是比较麻烦，但当你还是新手的时候，建议这样去算几遍熟悉一下。当然，平常我们肯定不需要这样费劲，简单几步就可以估算出来。怎么做呢？通过这两段代码的练习，大家有没有发现：

- 对于没有循环的代码，它的时间复杂度都是 O(1)
- 对于循环代码，我们只需要关注最内层循环的代码执行次数

`更简单来说，我们只需要关注一段代码里是否有循环，如果有就直接看最内层循环的时间复杂度`。

## 常见的时间复杂度

复杂度的量级大体由以下几种：

- 常量阶 O(1) 
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n<sup>2</sup>)
- 指数阶 O(2<sup>n</sup>)
- 阶乘阶O(n!)

各种时间复杂度的执行效率如下图所示：

<img src="/Users/dennisge/Library/Application Support/typora-user-images/image-20201223173741587.png" alt="image-20201223173741587" style="zoom:50%;" />

如图可知:

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)  < O(2^n) < O(n!)
```
其中，O(1) 表示算法最优。指数阶和阶乘阶的算法执行效率已经太低了，我们这里就不介绍了。我们前面几种多项式的复杂度。

### 常量阶 O(1)

常量阶时间复杂度O(1)，表示算法的执行时间不随着数据规模 n 的增大而增长。如下面这段代码：

```js
const N = 50;
const sum = (N + 1) * N / 2;
console.log(sum);
```

根据上面教的计算方法，我们可以知道时间复杂度为 O(3) 。根据加法原则，O(3) = O(1) + O(1) + O(1) = O(1)。我们没必要每次这样算，只要记住：`只要算法不存在循环或者递归等语句，代码的时间复杂度都记为 O(1)`。

### 对数阶 logn

`对数时间(logarithmic time)`, 稍微显得难理解一点。不过如果你了解对数，其实也很简单。例如二分查找，每一次查找都会去掉一半的元素，但最后一次元素个数就是 1。假设数组大小为n, 要经过 x 轮查找，则

```
    n * (1/2)^x = 1
```

则

```
    x = log_{2}n
```

logn是简写，一般忽略底数。

### 线性阶 O(n)

`线性时间(linear time)`, 算法执行时间和列表大小成正比。

### 线性对数阶 O(nlogn)

### 平方阶 O(n<sup>2</sup>)

`二次项时间(quadratic time)`, 通常是两层循环的算法。

### 简易估算方法

对于一个算法的时间复杂度，根据以上理论，大体按下面的步骤来估算复杂度。 以这个程序为例：

```
sum = 0;            
for( i = 0; i < n; i++)
    for( j = i; j < n; j++)
        sum++;
```

**1. 忽略简单语句**
对于简单复杂语句，它执行次数是一个常数，复杂度为O(1)。如果还存在循环，O(1)对结果不影响。

**2. 关注循环语句**
对于循环语句，要认真分析其循环执行的次数。例子中，外层循环要执行 n 次，内层循环要

```
    n + (n-1) + ... + 2 + 1 = (n + 1)/2
```

所以总次数T(n)为

```
    T(n) = n * (n+1)/2 = 1/2*n^2 + 1/2*n
```

**3. 忽略常数项，保留高次项**
对于一个多项式，当n→∞时，完全由最高项次决定。所以

```
    T(n) = O(1/2*n^2 + 1/2*n) = O(n^2 + n) = O(n^2)
```

对于有的程序，复杂度还是很不好计算。所以要多练习，写一个程序之后，自己主动去算一下它的复杂度，慢慢就熟练了。


## 总结

对于如何计算算法的时间复杂度，很多人都感觉很头疼。我给的建议是，按照上面的步骤多练习，多去主动算程序的时间复杂度。这样慢慢自己就会掌握技巧，并且提醒自己保证自己程序的执行效率。

## 参考

- [Big-O Complexity Chart](https://www.bigocheatsheet.com/)
- [循序渐进带你学习时间复杂度和空间复杂度](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650563136&idx=1&sn=c03ac8a5548ea28b34d624569855922e&chksm=f1fed4c3c6895dd56d079a5de77568c31cd9934ecb388ce6ba876002fec4b3487b6c5d51d984&scene=0#rd)
- [数据结构与算法之美](https://time.geekbang.org/column/article/40036)
- [You need to understand Big O notation](https://hackernoon.com/you-need-to-understand-big-o-notation-now-4ada3d2ec93a)

